# 第一章 Java多线程技能


## 1. 要点
 ### Thread相较于Runnable的限制
 使用继承 Thread 类的方式创建新线程时，最大的局限就是不支持多继承
 因为 Java 语言的特点就是单根继承，所以为了支持多继承，完全可以实现 Runnable 接口的方式

```text
在使用多线程技术时，代码的运行结果与代码执行顺序或调用顺序是无关的
```

 ```text
synchronized 可以在任意对象及方法上加锁，而加锁的这段代码称为“互斥区”或“临界区”。当一个线程想要执行同步方法里面的代码时，线程首先尝试去拿这把锁，如果能够拿到这把锁，那么这个线程就可以执行 synchronize 里面的代码。如果不能拿到这把锁，那么这个线程就会不断地尝试拿这把锁，直到能够拿到为止，而且是有多个线程同时去争抢这把锁。
 ```



## 2. 其他方法

### 1. isLive()

方法 isAlive() 的功能是判断当前的线程是否处于活动状态

只限制于当前类是继承Thread类，在继承Runnable时无效。

### 2. sleep() 

方法 sleep() 的作用是在指定的毫秒数内让当前“正在执行的线程”休眠（暂停执行）。
这个“正在执行的线程”是指 this.currentThread() 返回的线程

### 3. getId()

getId() 方法的作用是取得线程的唯一标识。

### 4. interrupt()

停止一个线程

这个方法不会终止一个正在运行的线程，还需要加入一个判断才可以完成线
程的停止

常规线程停止的情况：

1）使用退出标志，使线程正常退出，也就是当 run 方法完成后线程终止。
2）使用 stop 方法强行终止线程，但是不推荐使用这个方法，因为 stop 和 suspend 及
resume 一样，都是作废过期的方法，使用它们可能产生不可预料的结果。
3）使用 interrupt 方法中断线程。



Thread.java 类里提供了两种方法。
1）this.interrupted()：测试当前线程是否已经中断。
2）this.isInterrupted()：测试线程是否已经中断。 

### 5. suspend() resume()

 - suspend() 暂停线程
 - resume() 恢复暂停的线程
 
 
### 6. yield()

放弃当前的CPU资源,将它让给其他的任务去占用CPU的执行时间

### 7. stop()

停止线程的运行

